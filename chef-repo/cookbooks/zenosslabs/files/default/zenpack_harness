#!/usr/bin/env python
"""zenpack_harness

Provides a comprehensive harness for building and testing ZenPacks. Also
manages multiple Zenoss configurations installed on the same server to allow a
ZenPack to be tested against multiple Zenoss configurations.

"""

import compiler
import glob
import os
import re
import sys

from subprocess import Popen, PIPE


class ASTVisitor(compiler.visitor.ASTVisitor):
    """Visitor that turns module attributes into a dict.

    Instances of this class are to be fed into the second parameter of
    compiler.visitor.walk.

    """
    items = {}

    def __getitem__(self, key):
        return self.items[key]

    def visitAssign(self, node):
        """Called for each Assign node in the tree."""
        name_node = node.getChildren()[0]
        value_node = node.getChildren()[1]

        name = name_node.name
        value = None

        # Scalars.
        if hasattr(value_node, 'value'):
            value = value_node.value

        # Lists.
        elif hasattr(value_node, 'nodes'):
            value = [x.value for x in value_node.nodes]

        self.items[name] = value


class ShellError(Exception):
    def __init__(self, command, returncode, stdout=None, stderr=None):
        self.command = command
        self.returncode = returncode
        self.stdout = stdout
        self.stderr = stderr

    def __str__(self):
        buf = "'%s' returned non-zero exit status %s" % (
            self.command, self.returncode)

        if self.stdout:
            buf = "%s\n\n--- STDOUT ---\n%s" % (buf, self.stdout)

        if self.stderr:
            buf = "%s\n\n--- STDERR ---\n%s" % (buf, self.stderr)

        return buf

    def __repr__(self):
        return str(self)


def shell(command):
    """Helper method to get the output from a command."""
    p = Popen(command, stdout=PIPE, stderr=PIPE, shell=True)
    stdout, stderr = p.communicate()

    if p.returncode != 0:
        raise ShellError(command, p.returncode, stdout, stderr)

    return stdout


def print_header(level, title):
    if level != 0:
        print "\n"

    print title
    if level < 2:
        print "=" * 79
    elif level == 2:
        print "-" * 79
    elif level > 2:
        print "~" * 79

    print


class ZenossManager(object):
    """Manages multiple Zenoss configurations on the same server."""

    def run_bundle(self, bundle, suppress_errors=False):
        try:
            for command in bundle:
                shell(command)
        except ShellError, ex:
            if not suppress_errors:
                raise ex

    def run_bundles(self, bundles, suppress_errors=False):
        for bundle in bundles:
            self.run_bundle(bundle, suppress_errors=suppress_errors)

    def setup(self, zenoss_version, zenoss_flavor):
        """Setup a Zenoss environment for testing ZenPacks."""

        print "* Tearing down any existing environment"
        self.tear_down()

        lv_name = "zenoss/%s_%s" % (zenoss_version, zenoss_flavor)
        lv_device = "/dev/%s" % lv_name

        if not os.path.exists(lv_device):
            raise Exception("%s doesn't exist." % lv_device)

        try:
            print "* Creating zenoss/sandbox logical volume"
            print "* Mounting sandbox volume on /opt/zenoss"
            self.run_bundle([
                "sudo /usr/sbin/lvcreate -l25%%ORIGIN -s -n sandbox %s" % lv_name,
                "sudo mount /dev/zenoss/sandbox /opt/zenoss",
                ])

            if zenoss_version.startswith('3'):
                print "* Linking MySQL datadir to /opt/zenoss/datadir"
                print "* Starting mysqld"
                self.run_bundle([
                    "sudo ln -sf /opt/zenoss/datadir /var/lib/mysql",
                    "sudo /sbin/service mysqld start",
                    ])

            elif zenoss_version.startswith('4'):
                print "* Linking ZenDS datadir to /opt/zenoss/datadir"
                print "* Starting zends"
                self.run_bundle([
                    "sudo ln -sf /opt/zenoss/datadir /opt/zends/data",
                    "sudo /sbin/service zends start",
                    ])

                print "* Starting rabbitmq-server"
                print "* Starting memcached"
                self.run_bundles([
                    ("sudo /sbin/service rabbitmq-server start",),
                    ("sudo /sbin/service memcached start",),
                    ], suppress_errors=True)

            print "* Starting zenoss (minimal daemons)"
            self.run_bundle([
                "sudo /sbin/service zenoss start",
                ])
        except ShellError, ex:
            print ex
            sys.exit(1)

    def tear_down(self):
        """Tear down the Zenoss test environment.

        tear_down shouldn't need to be called explicitly as setup will call it
        before doing a setup.

        """
        self.run_bundles([
            ("sudo /sbin/service zenoss stop",),
            ("sudo /sbin/service mysqld stop",),
            ("sudo /sbin/service zends stop",),
            ("sudo /sbin/service memcached stop",),
            ("sudo umount -f /opt/zenoss",),
            ("sudo /usr/sbin/lvremove -f zenoss/sandbox",),
            ], suppress_errors=True)


class ZenPackHarness(object):
    """Comprehensive harness to build and test Zenpacks."""

    build_labels = None
    zenpack_name = None
    zenpack_directory = None
    zenpack_dependencies = None

    def __init__(self, build_labels=None):
        self.zenpack_directory = os.getcwd()

        if build_labels is None:
            self.build_labels = {}
        else:
            self.build_labels = build_labels

        tree = compiler.parseFile(os.path.join(
            self.zenpack_directory, 'setup.py'))

        visitor = compiler.visitor.walk(tree, ASTVisitor())

        self.zenpack_name = visitor['NAME']
        self.zenpack_dependencies = []
        for dependency in visitor['INSTALL_REQUIRES']:
            if not dependency.startswith('ZenPacks.'):
                continue

            self.zenpack_dependencies.append(re.split(r'[=<>]', dependency)[0])

    def run_build(self):
        print_header(1, "Building Egg")

        try:
            shell("sudo chmod 775 .")
            shell("sudo chown -R zenoss:jenkins .")
            shell("sudo rm -Rf build dist *.egg-info")

            print shell(
                "sudo -u zenoss -i "
                "'cd %s ; python setup.py bdist_egg'" % (
                    self.zenpack_directory))

            shell("sudo -u zenoss -i mkdir -p /opt/zenoss/zenpack_eggs")
            shell("sudo cp dist/*.egg /opt/zenoss/zenpack_eggs/")
        except ShellError, ex:
            print ex
            sys.exit(1)

    def install_dependencies(self):
        print_header(1, "Installing Dependencies")

        jenkins_url = os.environ.get('JENKINS_URL', None)
        if not jenkins_url:
            print "Dependencies can't be installed without JENKINS_URL."
            sys.exit(1)

        if len(self.build_labels.keys()) < 1:
            print "Dependencies can't be installed without BUILD_TAG."
            sys.exit(1)

        url_prefix = "%s/job" % jenkins_url
        url_suffix = (
            '%s/lastSuccessfulBuild/artifact/%%2Azip%%2A/archive.zip' % (
                ','.join('='.join(x) for x in self.build_labels.items())))

        for dependency in self.zenpack_dependencies:
            print "* %s\n" % dependency

            url = "%s/%s/%s" % (url_prefix, dependency, url_suffix)

            try:
                print "  * downloading.."
                shell(
                    "sudo -u zenoss -i "
                    "wget -O /opt/zenoss/zenpack_eggs/%s.zip '%s'" % (
                        dependency, url))

                print "  * unzipping.."
                shell(
                    "sudo -u zenoss -i "
                    "unzip -j -d /opt/zenoss/zenpack_eggs "
                    "/opt/zenoss/zenpack_eggs/%s.zip" % (
                        dependency))

                print "  * installing.."
                shell(
                    "sudo -u zenoss -i zenpack --install "
                    "/opt/zenoss/zenpack_eggs/%s-*.egg 2>&1" % (
                        dependency))

                print
            except ShellError, ex:
                print ex
                sys.exit(1)

    def run_install(self):
        if self.zenpack_dependencies:
            self.install_dependencies()

        print_header(1, "Installing")

        try:
            print shell(
                "sudo -u zenoss -i zenpack --install "
                "/opt/zenoss/zenpack_eggs/%s-*.egg 2>&1" % (
                    self.zenpack_name))

        except ShellError, ex:
            print ex
            sys.exit(1)

    def run_generictests(self):
        print_header(1, "Running Generic Tests")
        print "Coming soon!"

    def run_unittests(self):
        print_header(1, "Running Unit Tests")

        test_modules_glob = '/opt/zenoss/ZenPacks/%s-*.egg/%s/tests/*.py' % (
            self.zenpack_name, self.zenpack_name.replace('.', '/'))

        # We need __init__.py and at least one other file.
        if len(glob.glob(test_modules_glob)) < 2:
            print "No unit tests found.\n"
            return

        try:
            print shell(
                "sudo -u zenoss -i nosetests "
                "-w /opt/zenoss/ZenPacks/%(name)s-*.egg/ZenPacks "
                "--with-coverage --cover-package=%(name)s "
                "%(name)s.tests 2>&1" % (
                    {'name': self.zenpack_name}),)

        except ShellError, ex:
            print ex
            sys.exit(1)

    def run_remove(self):
        print_header(1, "Removing")

        try:
            print shell("sudo -u zenoss -i zenpack --remove %s" % (
                self.zenpack_name))
        except ShellError, ex:
            # If a ZenPack can't be removed because it's a dependency of other
            # installed ZenPacks, we'll skip the remove tests.
            if "cannot be removed because it is required by" in str(ex):
                print "ZenPack is a dependency of other installed ZenPacks.\n"
                return

            # A regression was introduced in Zenoss 4.1.0 that caused the
            # dependency error to be covered by the following message. We'll
            # treat it the same as a dependency violation.
            if "exceptions must be old-style classes" in str(ex):
                print "ZenPack is a dependency of other installed ZenPacks.\n"
                return

            print ex
            sys.exit(1)


def main():
    """Run zenpack_harness (ZenPackHarness) from the command line.

    ZenPackHarness requires two parameters: zenoss_version and zenoss_flavor.
    This method attempts to get these parameters from command line options or
    from the Jenkins BUILD_TAG environment variable. The command line options
    will take precendence over what is set in BUILD_TAG.

    The following commands (steps) are supported:

        build
        install
        generictests
        unittests
        remove

    """

    from optparse import OptionParser

    zenoss_version = None
    zenoss_flavor = None

    parser = OptionParser()
    parser.add_option('-v', '--version', help="Zenoss version to test against")
    parser.add_option('-f', '--flavor', help="Zenoss flavor to test against")

    parser.add_option('-s', '--setup',
        help="No steps. Only setup Zenoss environment",
        default=False, action="store_true")

    parser.add_option('-t', '--teardown',
        help="No steps. Only tear down Zenoss environment",
        default=False, action="store_true")

    options, args = parser.parse_args()

    if len(args) < 1:
        args = ('build', 'install', 'generictests', 'unittests', 'remove')

    build_tag = os.environ.get('BUILD_TAG', None)
    build_labels = {}
    if build_tag:
        build_labels = dict(
            x.split('=') for x in build_tag.split('-')[1].split(','))

    if options.version:
        zenoss_version = options.version
    elif 'zenoss_version' in build_labels:
        zenoss_version = build_labels['zenoss_version']
    else:
        print >> sys.stderr, "Zenoss version not found on command line or BUILD_TAG."
        sys.exit(1)

    if options.flavor:
        zenoss_flavor = options.flavor
    elif 'zenoss_flavor' in build_labels:
        zenoss_flavor = build_labels['zenoss_flavor']
    else:
        print >> sys.stderr, "Zenoss flavor not found on command line or BUILD_TAG."
        sys.exit(1)

    # We only need a setup.py in the current directory for running steps.
    if not options.setup and not options.teardown:
        if not os.path.isfile('setup.py'):
            print >> sys.stderr, "setup.py doesn't exist in current directory."
            sys.exit(1)

    zman = ZenossManager()

    if options.setup or (not options.setup and not options.teardown):
        print_header(0, "Setting up environment for Zenoss %s (%s)" % (
            zenoss_version, zenoss_flavor))

        zman.setup(zenoss_version, zenoss_flavor)

    if not options.setup and not options.teardown:
        try:
            try:
                harness = ZenPackHarness(build_labels)
                for arg in args:
                    harness_method = getattr(harness, 'run_%s' % arg, None)
                    if not harness_method:
                        print >> sys.stderr, (
                            "%s is not a supported command.") % arg

                        sys.exit(1)

                    harness_method()
            except SystemExit, ex:
                zman.tear_down()
                sys.exit(ex.code)
        finally:
            zman.tear_down()

    if options.teardown:
        zman.tear_down()


if __name__ == '__main__':
    main()
