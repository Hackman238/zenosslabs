#!/usr/bin/env python
"""zenpack_harness

Provides a comprehensive harness for building and testing ZenPacks. Also
manages multiple Zenoss configurations installed on the same server to allow a
ZenPack to be tested against multiple Zenoss configurations.

"""

import compiler
import glob
import os
import pkg_resources
import re
import sys

from subprocess import Popen, PIPE


class ASTVisitor(compiler.visitor.ASTVisitor):
    """Visitor that turns module attributes into a dict.

    Instances of this class are to be fed into the second parameter of
    compiler.visitor.walk.

    """
    items = {}

    def __getitem__(self, key):
        return self.items[key]

    def visitAssign(self, node):
        """Called for each Assign node in the tree."""
        name_node = node.getChildren()[0]
        value_node = node.getChildren()[1]

        name = name_node.name
        value = None

        # Scalars.
        if hasattr(value_node, 'value'):
            value = value_node.value

        # Lists.
        elif hasattr(value_node, 'nodes'):
            value = [x.value for x in value_node.nodes]

        self.items[name] = value


class ShellError(Exception):
    def __init__(self, command, returncode, stdout=None, stderr=None):
        self.command = command
        self.returncode = returncode
        self.stdout = stdout
        self.stderr = stderr

    def __str__(self):
        buf = "'%s' returned non-zero exit status %s" % (
            self.command, self.returncode)

        if self.stdout:
            buf = "%s\n\n--- STDOUT ---\n%s" % (buf, self.stdout)

        if self.stderr:
            buf = "%s\n\n--- STDERR ---\n%s" % (buf, self.stderr)

        return buf

    def __repr__(self):
        return str(self)


def shell(command):
    """Helper method to get the output from a command."""
    p = Popen(command, stdout=PIPE, stderr=PIPE, shell=True)
    stdout, stderr = p.communicate()

    if p.returncode != 0:
        raise ShellError(command, p.returncode, stdout, stderr)

    return stdout


def print_header(level, title):
    if level != 0:
        print "\n"

    print title
    if level < 2:
        print "=" * 79
    elif level == 2:
        print "-" * 79
    elif level > 2:
        print "~" * 79

    print


class ZenossManager(object):
    """Manages multiple Zenoss configurations on the same server."""

    def run_bundle(self, bundle, suppress_errors=False):
        try:
            for command in bundle:
                shell(command)
        except ShellError, ex:
            if not suppress_errors:
                raise ex

    def run_bundles(self, bundles, suppress_errors=False):
        for bundle in bundles:
            self.run_bundle(bundle, suppress_errors=suppress_errors)

    def setup(self, zenoss_version, zenoss_flavor):
        """Setup a Zenoss environment for testing ZenPacks."""

        print "* Tearing down any existing environment"
        self.tear_down()
        self.tear_down()

        lv_name = "zenoss/%s_%s" % (zenoss_version, zenoss_flavor)
        lv_device = "/dev/%s" % lv_name

        if not os.path.exists(lv_device):
            raise Exception("%s doesn't exist." % lv_device)

        try:
            print "* Creating zenoss/sandbox logical volume"
            print "* Mounting sandbox volume on /opt/zenoss"
            self.run_bundle([
                "sudo /usr/sbin/lvcreate -l25%%ORIGIN -s -n sandbox %s" % lv_name,
                "sudo mount /dev/zenoss/sandbox /opt/zenoss",
                ])

            if zenoss_version.startswith('3'):
                print "* Linking MySQL datadir to /opt/zenoss/datadir"
                print "* Starting mysqld"
                self.run_bundle([
                    "sudo ln -sf /opt/zenoss/datadir /var/lib/mysql",
                    "sudo /sbin/service mysqld start",
                    ])

            elif zenoss_version.startswith('4'):
                print "* Linking ZenDS datadir to /opt/zenoss/datadir"
                print "* Starting zends"
                self.run_bundle([
                    "sudo ln -sf /opt/zenoss/datadir /opt/zends/data",
                    "sudo /sbin/service zends start",
                    ])

                print "* Starting rabbitmq-server"
                print "* Starting memcached"
                self.run_bundles([
                    ("sudo /sbin/service rabbitmq-server start",),
                    ("sudo /sbin/service memcached start",),
                    ], suppress_errors=True)

            print "* Starting zenoss (minimal daemons)"
            self.run_bundle([
                "sudo -u zenoss -i 'zenoss start'",
                ])
        except ShellError, ex:
            print ex
            sys.exit(1)

    def tear_down(self):
        """Tear down the Zenoss test environment.

        tear_down shouldn't need to be called explicitly as setup will call it
        before doing a setup.

        """
        self.run_bundles([
            ("sudo -u zenoss -i 'zenoss stop'",),
            ("sudo /sbin/service mysqld stop",),
            ("sudo /sbin/service zends stop",),
            ("sudo /sbin/service memcached stop",),
            ("sudo pkill -9 -f /opt/zenoss",),
            ("sudo kill -9 $(lsof -Fp /opt/zenoss | cut -b2-)",),
            ("sudo umount -f /opt/zenoss",),
            ("sudo /usr/sbin/lvremove -f zenoss/sandbox",),
            ], suppress_errors=True)


class ZenPackHarness(object):
    """Comprehensive harness to build and test Zenpacks."""

    build_labels = None
    zenoss_version = None
    zenpack_name = None
    zenpack_directory = None
    zenpack_dependencies = None

    def __init__(self, build_labels=None):
        self.zenpack_directory = os.getcwd()

        if build_labels is None:
            self.build_labels = {}
        else:
            self.build_labels = build_labels

            if 'zenoss_version' in build_labels:
                self.zenoss_version = '.'.join(
                    build_labels['zenoss_version'].split('.')[:2])

        tree = compiler.parseFile(os.path.join(
            self.zenpack_directory, 'setup.py'))

        visitor = compiler.visitor.walk(tree, ASTVisitor())

        self.zenpack_name = visitor['NAME']
        self.zenpack_dependencies = []
        for dependency in visitor['INSTALL_REQUIRES']:
            if not dependency.startswith('ZenPacks.'):
                continue

            self.zenpack_dependencies.append(re.split(r'[=<>]', dependency)[0])

    def run_pyflakes(self):
        print_header(1, "Running PyFlakes Static Analyzer")

        try:
            print shell(
                "sudo -u zenoss -i "
                "'cd %s ; find ZenPacks/ -name \\*.py | xargs pyflakes' "
                "|| :" % self.zenpack_directory)

        except ShellError:
            pass

    def run_pep8(self):
        print_header(1, "Running PEP-8 Code Style Analyzer")

        try:
            print shell(
                "sudo -u zenoss -i "
                "'cd %s ; find ZenPacks/ -name \\*.py | xargs pep8' "
                "|| :" % self.zenpack_directory)

        except ShellError:
            pass

    def run_build(self):
        print_header(1, "Building Egg")

        try:
            shell("sudo chmod 775 .")
            shell("sudo chown -R zenoss:jenkins .")
            shell("sudo rm -Rf build dist *.egg-info")

            print shell(
                "sudo -u zenoss -i "
                "'cd \"%s\" ; python setup.py bdist_egg'" % (
                    self.zenpack_directory))

            shell("sudo -u zenoss -i mkdir -p /opt/zenoss/zenpack_eggs")
            shell("sudo cp dist/*.egg /opt/zenoss/zenpack_eggs/")

            # Stage files into a directory with the right hierarchy so Jenkins
            # can automatically push it to a distribution site.
            if self.zenoss_version:
                shell("mkdir -p %s" % self.zenoss_version)
                shell("mv dist/ZenPacks.*.egg %s/" % self.zenoss_version)

        except ShellError, ex:
            print ex
            sys.exit(1)

    def install_dependencies(self, dependencies):
        platform = shell(
            "sudo -u zenoss -i 'python -c \""
            "import pkg_resources; "
            "print pkg_resources.get_supported_platform()"
            "\"'").strip()

        python = shell(
            "sudo -u zenoss -i 'python -c \""
            "import pkg_resources; "
            "print pkg_resources.PY_MAJOR"
            "\"'").strip()

        url_prefix = "http://192.168.4.4/api/download/"
        url_suffix = "\?zenoss_version=%s\&platform=%s\&python=%s" % (
            self.zenoss_version, platform, python)

        for dependency in dependencies:
            print "* %s\n" % dependency

            url = "%s%s%s" % (url_prefix, dependency, url_suffix)

            try:
                print "  * downloading.."
                shell(
                    "sudo -u zenoss -i "
                    "wget -O /opt/zenoss/zenpack_eggs/%s.egg '%s'" % (
                        dependency, url))

                print "  * installing.."
                shell(
                    "sudo -u zenoss -i zenpack --install "
                    "/opt/zenoss/zenpack_eggs/%s.egg 2>&1" % (
                        dependency))

                print
            except ShellError, ex:
                print ex
                sys.exit(1)

    def run_install(self):
        if self.zenpack_dependencies:
            print_header(1, "Installing Dependencies")

            if len(self.build_labels.keys()) < 1:
                print "Dependencies can't be installed without BUILD_TAG."
                sys.exit(1)

            if self.zenoss_version is None:
                print "Unable to determine Zenoss version."
                sys.exit(1)

            self.install_dependencies(self.zenpack_dependencies)

        print_header(1, "Installing")

        try:
            print shell(
                "sudo -u zenoss -i zenpack --install "
                "/opt/zenoss/zenpack_eggs/%s-*.egg 2>&1" % (
                    self.zenpack_name))

        except ShellError, ex:
            print ex
            sys.exit(1)

    def run_generictests(self):
        print_header(1, "Running Generic Tests")
        print "Coming soon!"

    def run_unittests(self):
        print_header(1, "Running Unit Tests")

        cover_dir = os.path.join(self.zenpack_directory, 'cover')

        test_modules_glob = '/opt/zenoss/ZenPacks/%s-*.egg/%s/tests/*.py' % (
            self.zenpack_name, self.zenpack_name.replace('.', '/'))

        # We need __init__.py and at least one other file.
        if len(glob.glob(test_modules_glob)) < 2:
            print "No unit tests found.\n"

            # Create empty coverage report.
            if not os.path.isdir(cover_dir):
                os.mkdir(cover_dir)

            cover_f = open(os.path.join(cover_dir, 'index.html'), 'w')
            cover_f.write("No unit tests to provide coverage for.\n")
            cover_f.close()

            # Create empty XUnit report.
            xunit_f = open(os.path.join(
                self.zenpack_directory, 'nosetests.xml'), 'w')

            xunit_f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            xunit_f.write('<testsuite name="nosetests" tests="0" errors="0" failures="0" skip="0">\n')
            xunit_f.write('<testcase classname="Nothing" name="testNothing" time="0.000" />\n')
            xunit_f.write('</testsuite>\n')
            xunit_f.close()

            return

        try:
            print shell(
                "sudo -u zenoss -i nosetests "
                "-w '/opt/zenoss/ZenPacks/%s-*.egg/ZenPacks' "
                "--with-xunit "
                "--xunit-file='%s/nosetests.xml' "
                "--with-coverage "
                "--cover-package=%s "
                "--cover-html "
                "--cover-html-dir='%s' "
                "%s.tests "
                "2>&1 || :" % (
                    self.zenpack_name,
                    self.zenpack_directory,
                    self.zenpack_name,
                    cover_dir,
                    self.zenpack_name))

        except ShellError:
            raise

    def run_remove(self):
        print_header(1, "Removing")

        try:
            print shell("sudo -u zenoss -i zenpack --remove %s" % (
                self.zenpack_name))

            # On successfully removal there is no output. Providing some.
            print "Done."

        except ShellError, ex:
            # If a ZenPack can't be removed because it's a dependency of other
            # installed ZenPacks, we'll skip the remove tests.
            if "cannot be removed because it is required by" in str(ex):
                print "ZenPack is a dependency of other installed ZenPacks.\n"
                return

            # A regression was introduced in Zenoss 4.1.0 that caused the
            # dependency error to be covered by the following message. We'll
            # treat it the same as a dependency violation.
            if "exceptions must be old-style classes" in str(ex):
                print "ZenPack is a dependency of other installed ZenPacks.\n"
                return

            print ex
            sys.exit(1)


def main():
    """Run zenpack_harness (ZenPackHarness) from the command line.

    ZenPackHarness requires two parameters: zenoss_version and zenoss_flavor.
    This method attempts to get these parameters from command line options or
    from the Jenkins BUILD_TAG environment variable. The command line options
    will take precendence over what is set in BUILD_TAG.

    The following commands (steps) are supported:

        pyflakes
        pep8
        build
        install
        generictests
        unittests
        remove

    """

    from optparse import OptionParser

    zenoss_version = None
    zenoss_flavor = None

    parser = OptionParser()
    parser.add_option('-v', '--version', help="Zenoss version to test against")
    parser.add_option('-f', '--flavor', help="Zenoss flavor to test against")

    parser.add_option('-s', '--setup',
        help="Setup Zenoss environment",
        default=False, action="store_true")

    parser.add_option('-t', '--teardown',
        help="Tear down Zenoss environment",
        default=False, action="store_true")

    options, args = parser.parse_args()

    zman = ZenossManager()

    # A teardown requires no parameters or environment variables.
    if options.teardown:
        zman.tear_down()
        sys.exit(0)

    # Default to running all steps if none are specified.
    if len(args) < 1:
        args = (
            'pyflakes', 'pep8', 'build', 'install', 'generictests', 'unittests',
            'remove',
            )

    # Get Zenoss configuration info from command line or environment variables.
    build_tag = os.environ.get('BUILD_TAG', None)
    build_labels = {}
    if build_tag:
        build_labels = dict(
            x.split('=') for x in build_tag.split('-')[1].split(','))

    if options.version:
        zenoss_version = options.version
    elif 'zenoss_version' in build_labels:
        zenoss_version = build_labels['zenoss_version']
    else:
        print >> sys.stderr, "Zenoss version not found on command line or BUILD_TAG."
        sys.exit(1)

    if options.flavor:
        zenoss_flavor = options.flavor
    elif 'zenoss_flavor' in build_labels:
        zenoss_flavor = build_labels['zenoss_flavor']
    else:
        print >> sys.stderr, "Zenoss flavor not found on command line or BUILD_TAG."
        sys.exit(1)

    # We only need a setup.py in the current directory for running steps.
    if options.setup:
        print_header(0, "Setting up environment for Zenoss %s (%s)" % (
            zenoss_version, zenoss_flavor))

        zman.setup(zenoss_version, zenoss_flavor)
        sys.exit(0)

    if not os.path.isfile('setup.py'):
        print >> sys.stderr, "setup.py doesn't exist in current directory."
        sys.exit(1)

    harness = ZenPackHarness(build_labels)
    for step in args:
        harness_method = getattr(harness, 'run_%s' % step, None)
        if not harness_method:
            print >> sys.stderr, (
                "%s is not a supported step.") % step

            sys.exit(1)

        harness_method()


if __name__ == '__main__':
    main()
